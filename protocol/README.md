基本语法
=======

通讯协议描述文档由：模块、接口和字段组成，每份通讯协议描述文档可以包含多个通讯协议模块。

每个通讯协议模块又可以包含多个通讯接口描述，每个通讯接口描述分别由上行和下行数据格式两部分组成。

上行数据格式是对请求格式的描述，下行数据格式是对响应格式的描述。

格式描述的最小单位是字段，每个字段包含字段名称和字段类型。

声明模块使用“mod”关键字，声明接口使用“api”关键字，声明上行和下行数据格式分别使用“in”和“out”关键字。

声明模块和接口时需要使用“=”运算符指定模块和接口的ID，模块ID和接口ID必须是0 ~ 255之间的整数，模块ID必须唯一，同一个模块中的接口ID也必须唯一。

协议描述语言使用“//”作为单行注释的起始符号。

示例1

    // 玩家模块
    mod player = 0 
    {
      // 玩家登录接口
      api login = 0 
      {
        in 
        {
          username : text  // 玩家帐号
          password : text  // 登录密码
        }
        
        out
        {
          result : byte    // 登录结果（1表示成功、2表示失败、3表示首次登录）
        }
      }
    }

示例1中声明了一个玩家模块，这个模块中包含一个登录接口，玩家模块和玩家登录接口的ID都正好为0，玩家登录接口上行数据包含两个text类型的字段，分别是玩家帐号和登录密码，下行数据包含一个byte类型的字段用于表示登录结果。

数据类型
=======

通讯协议描述语言内置了一系列的数据类型，按大类可以分为：整数类型、枚举类型、字符串类型、列表类型。

整数类型
-------

以下这些数据类型统称为整型数据类型：

* int8，单字节有符号整数，可以表 -128 到 +127 范围的整数
* int16，双字节有符号整数，可以表示 -32768 到 +32767 范围的整数
* int32，四字节有符号整数，可以表示 -2,147,483,648 到 +2,147,483,647 范围的整数
* int64，八字节有符号整数，可以表示 -9,223,372,036,854,775,808 到 +9,223,372,036,854,775,807范围的整数
* uint8，单字节无符号整数，可以表示 0 到 255 范围的整数
* uint16，双字节无符号整数，可以表示 0 到 65535 范围的整数
* uint32，四字节无符号整数，可以表示 0 到 4,294,967,295 范围的整数
* uint64，八字节无符号整数，可以表示 0 到 18,446,744,073,709,551,615 范围的整数

为方便协议描述文档的书写，协议描述语言的语法上支持以下几个整数类型别名：

* char，对应int8
* byte，对应int8
* int，对应int32
* uint，对应uint32

布尔类型
-------
布尔类型在实现中使用单个字节表示，但只运行0和1两个值，0代表false，1代表true。

字符串类型
---------

协议描述语言支持两种字符串类型，分别是：

* text8，可以表示 0 到 255 个字符的字符串
* text16，可以表示 0 到 65535 个字符的字符串

协议描述语言还支持以下几个字符串类型的别名：

* text，对应text16
* string，对应text15

列表类型
-------

列表类型起到发送或返回多个相同结构数据的作用，可以利用列表类型批量返回数据或批量请求数据。

列表类型与字符串类型一样，分别支持以下两种列表类型：

* list8，最多可以包含 255 个元素的列表
* list16，最多可以包含 65535 个元素的列表

可以用缩写list表示list8。

列表类型不能单独存在，在使用列表类型时需要同时声明列表中每个元素的格式。

示例2

    // 物品模块
    mod item = 1 
    {
      // 物品信息获取接口
      api get_items = 0 
      {
        in 
        {
          item_ids : list { %% 物品ID列表
            id : int        %% 物品ID
          }
        }
        
        out 
        {
          item_infos : list { %% 物品信息列表
            name : text       %% 物品名称
            desc : text       %% 物品描述
          }
        }
      }
    }

示例2声明了一个接收物品id列表并返回相关物品信息的通讯接口，上行数据中的item_ids是列表类型，其中每个元素都包含一个名为id的int类型的字段，下行数据中的items也是list类型，但其中每个元素包含两个text类型的字段分别表示物品的名称和描述。

枚举类型
-------

枚举类型是整数类型的延伸，适用于需要固定几种值的的情况，例如示例1中的登录接口就可以定义成枚举类型，用来区别不同的登录结果。

以下为协议描述语言支持的枚举类型：

* enum8，取值范围对应int8
* enum16，取值范围对应int16
* enum32，取值范围对应int32
* enum64，取值范围对应int64

枚举类型不能单独使用，在使用枚举类型时需要先在模块头部声明枚举类型和它的值范围，然后在协议字段中引用该类型。

示例2

    // 玩家模块
    mod player = 0 
    {
      // 登录结果
      type login_result enum
      {
            SUCCEED    = 1  %% 登录成功
            FAILED     = 2  %% 登录失败
            FIRST_TIME = 3  %% 首次登录
      }

      // 玩家登录接口
      api login = 0
      {
        in
        {
          username : text  %% 玩家帐号
          password : text  %% 登录密码
        }
        
        out
        {
          result : login_result
        }
      }
    }

示例2演示了把示例1中的下行数据字段result改成枚举类型的情况，通过示例1到示例2的演变，可以看出在这个应用场景下，枚举类型可以提高协议文档的可读性。

通讯层代码生成工具会将枚举类型生成常量定义，使用枚举类型将有效提高代码的可维护性和可读性。

实现细节
=======

通讯协议语法除了对数据类型的数据格式有严格规定以外，并没有对通讯协议的实现有任何假设，这里提出一种基于二进制数据的实现方式，在没有更好的实现方式时，建议首先采用此规范。

包
--

上下行数据最终都被打成一个个的二进制数据包，包以通用的格式定义，其格式如下：

    0              31             N
    +---------------+-------------+
    |      size     |     body    |
    +---------------+-------------+
    
每个包由4个字节（32位）的包头size，和N字节的包体body组成。

包头中size是一个两字节无符号整型，用于表示包的字节长度N，所以最大允许的包体长度是65535字节，即65K。

上下行数据的内容就存放与包体中，包体使用通用的格式以区别不同模块和接口的上下行数据，其格式如下：

    0              15           N - 2
    +---------------+-------------+
    |  mod  |  act  |     data    |
    +---------------+-------------+

如上所示，包体使用两个字节分别用于存放模块ID和接口ID，后续的部分才是真正的上下行数据内容。

上下行数据内容的按照协议描述语言支持的数据类型，以及具体接口的上下行数据描述进行逐个字段的解析。

其中整数类型和枚举类型属于简单数据类型，具体占用的字节长度已经在前文中说明，这里不在阐述。

列表类型和字符串类型属于复杂类型，这两种类型都需要额外的空间用于存储元素个数或文本长度。

对于列表类型和字符串类型的表示，使用与数据包类似的头部和主体分离的表示方式。

list8和text8类型的格式定义如下：

    0       8                     N
    +-------+---------------------+
    | size  |        body         |
    +-------+---------------------+

list16和text16类型的格式定义如下：

    0       8      15             N
    +-------+-------+-------------+
    |      size     |     body    |
    +-------+-------+-------------+

在列表类型中，size对应元素个数而不是字节长度，在字符串类型中size对应字符长度。

list8、text8和list16、text16的区别在于用于头部size的字段占用的空间大小。

书写规范
=======

通讯协议描述语言本身使用的是类C语法，并没有强制性的格式要求，花括号可以写在声明的同一行也可以换行写，字段可以注释也可以不注释，但是在进行多人协作的时候，文档必须按统一的规范书写，否则文档将起不到记录和辅助协作的作用还可能妨碍协作的进行。

这里给出推荐的文档书写格式，在没有更好的文档格式规范之前，建议首先采用此规范。

空格
----

1. 使用两个空格作为缩进符号
2. 模块名称和“=”之间空一格，“=”和模块ID之间空一格
3. 接口名称和“=”之间空一格，“=”和接口ID之间空一格
4. 字段名“:”之间空一格，“:”和类型名之间空一格
5. 枚举和列表类型名和紧跟的“{”之间空一格
6. 枚举值名称和值之间的“=”，使用多个空格对齐起始位置

换行
----

1. 模块起始的花括号独占一行
2. 接口起始的花括号独占一行
3. 接口与接口之间空一行
4. 上行数据和下行数据起始的花括号独占一行
5. 上行与下行数据格式声明之间空一行
6. 枚举类型和列表类型起始的花括号与所属字段同行书写

注释
----

1. 所有模块、接口、字段都需要明确注释用途，有值范围的需在注释中写明值范围，值有特殊含义的需要写明具体含义
2. 注释使用//加一个空格起始
3. 模块注释和接口注释写在模块声明和接口声明的顶部，可以用多行注释书写
4. 字段注释紧跟在字段声明之后，保持同一行书写，对于枚举和列表类型，注释跟在起始的花括号之后
5. 同一级的字段注释起始点用空格保持对齐

大小写
-----

1. 所有模块名、接口名、字段名均用全小写格式，单词之间使用一个“\_”连接
2. 枚举类型的枚举值名称使用全大写格式，单词之间使用一个“\_”连接


